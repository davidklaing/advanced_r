---
title: "Functions"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Quiz

1. What are the three components of a function?
> its name, its arguments, and its contents?
> nope: body, arguments, and environment

2. What does the following code return?

```
x <- 10
f1 <- function(x) {
  function() {
    x + 10
  }
}
f1(1)()
```

> 20? Let's see...

```{r}
x <- 10
f1 <- function(x) {
  function() {
    x + 10
  }
}
f1(1)()
```

> Lol. Fooled me.

3. How would you more typically write this code?

```{r}
`+`(1, `*`(2, 3))
```

Like this:

```{r}
1 + 2*3
```

> correct

4. How could you make this call easier to read?

```{r}
mean(, TRUE, x = c(1:10, NA))
```

Like this:

```{r}
mean(x = c(1:10, NA), na.rm = TRUE)
```

> correct

5. Does the following function throw an error when called? Why/why not?

```
f2 <- function(a, b) {
  a * 10
}
f2(10, stop("This is an error!"))
```

> I expect that if we passed in something like b = 5, we'd get an error because b never got used in the function. But since we're passing in an error message, maybe that nullifies the "never got used" error because a different error was passed in instead? But it's not like it was actually used, so that wouldn't really make sense. I have no idea. Let's see.

```{r}
f2 <- function(a, b) {
  a * 10
}
f2(10, stop("This is an error!"))
```

> Okay, turns out I was wrong about that initial claim too. The function runs fine even if you give it a normal input. (I wonder why I've seen that error before in other situations?)

6. What is an infix function? How do you write it? What’s a replacement function? How do you write it?

> No clue.

7. What function do you use to ensure that a cleanup action occurs regardless of how a function terminates?

> No clue.
> answer: `on.exit()`. That could be very handy!

## Function components

### Exercises

1. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

> `is.function`
> `is.primitive`

2. This code makes a list of all functions in the base package.

```{r}
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)
```

Use it to answer the following questions:

  a. Which base function has the most arguments?
  b. How many base functions have no arguments? What’s special about those functions?
  c. How could you adapt the code to find all primitive functions?

```{r}
arg_lengths <- sapply(funs, function(x) length(formals(x)))

# a: `scan`
names(which.max(arg_lengths))

# b: 224 have no arguments. Most of them are primitive...but not all?
no_arg_functions <- names(arg_lengths[arg_lengths == 0])

length(no_arg_functions)

mean(sapply(funs[no_arg_functions], is.primitive))

# c: change `is.function` to `is.primitive`, presumably?
objs <- mget(ls("package:base"), inherits = TRUE)
prim_funs <- Filter(is.primitive, objs)

length(prim_funs)

length(funs)
```


3.What are the three important components of a function?
> Its formals (arguments), its body (the code in the body of the function), and its environment.

4. When does printing a function not show what environment it was created in?
> When it was created in the global environment?

Q: need more information about environments. I don't have a strong enough understanding of this.

## Lexical scoping